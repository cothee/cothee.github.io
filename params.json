{
  "name": "the use of pipe",
  "tagline": "UNP(II) reading notes",
  "body": "# the use of pipe #\r\n  the head file of the pipe() function is **<unistd.h>**:\r\n```cpp\r\n#include <unistd.h>\r\n\r\nint pipe(int fd[2]);\r\n```\r\n## 1. the use of pipe in inter-process communications ##\r\n&ensp;&ensp;Pipe is often used for communications between processes which have genetic relationship with each other. the following is an example given by UNP(II):\r\n```cpp\r\n#include <unistd.h>      /*pipe() && fork() & write() & read() & STDOOUT_FILENO*/\r\n#include <sys/types.h>  /* pid_t ssize_t*/\r\n#include <sys/wait.h>  /* waitpid() */\r\n#include <stdio.h>    /*fgets(), stdin*/\r\n#include <string.h>  /*strlen*/ \r\n\r\n#define BUFFERSIZE 20\r\n\r\nvoid client(int readfd, int writefd);\r\nvoid server(int readfd, int writefd);\r\n    \r\nint main(int argc, char *argv[]) {\r\n int pipe1[2], pipe2[2];\r\n pid_t child_pid;\r\n \r\n pipe(pipe1);  /* create two pipes */\r\n pipe(pipe2);\r\n \r\n if( (child_pid = fork()) == 0) {    /*child process for server */\r\n  close(pipe1[1]);  /* close write fd*/\r\n  close(pipe2[0]);  /* close read fd */\r\n   \r\n  server(pipe1[0], pipe2[1]);  /*read from pipe1[0], and write to pipe2[1]*/\r\n  exit(); \r\n }\r\n \r\n close(pipe1[1]);\r\n close(pipe2[0]);\r\n \r\n client(pipe1[1], pipe2[0]); /*write to pipe1[0], and read from pipe2[1]*/\r\n \r\n waitpid(child_pid, NULL, 0);\r\n \r\n}\r\n\r\nvoid client(int readfd, int writefd) {\r\n size_t len;\r\n ssize_t n;\r\n char buff[BUFFERSIZE];\r\n \r\n fgets(buff, BUFFERSIZE, stdin);\r\n \r\n len = strlen(buff);\r\n\r\n if (buff[len-1] == '\\n'){\r\n  len--;\r\n }\r\n \r\n write(writefd, buff, len);\r\n \r\n while ((n = read(readfd, buff, BUFFERSIZE)) > 0) {\r\n  write(writefd, buff, n);\r\n }\r\n}\r\n\r\nvoid server(int readfd, int writefd) {\r\n size_t len;\r\n ssize_t n;\r\n int fd;\r\n char buff[BUFFERSIZE+1];\r\n \r\n if (n = read(readfd, buff, BUFFERSIZE) == 0) {\r\n  printf(\"server read error!\");\r\n  eixt(1);\r\n }\r\n buff[n] = '\\0';\r\n \r\n if ((fd = open(buff,O_RDONLY)) < 0) {\r\n  snprintf(buff + n, sizeof(buff) - n, \"can not open: %s\\n\", stderror(errno));\r\n  n = strlen(buff);\r\n  write(writefd, buff, n);\r\n }\r\n else {\r\n  while ((n = read(fd, buff, BUFFERSIZE)) > 0){\r\n   write(writefd, buff, n);\r\n  }\r\n  close(fd);\r\n }\r\n\r\n}\r\n```\r\n\r\n## 2. the use of pipe( combing with select) in controlling the executing time of a process ##\r\n&ensp;&ensp; We can alose use pipe combing with select() to controlling the executing time of a child process, \r\nI first saw this kind of usage in one of our team projects named [Qconf](https://github.com/Qihoo360/QConf/blob/master/agent/qconf_script.cc#L50).\r\nI'll just paste the codes here straightforward, and then give my understanding of these codes.\r\n```cpp\r\nint execute_script(const string &script, const long mtimeout)\r\n{\r\n if (script.empty()) return QCONF_ERR_PARAM;\r\n\r\n int     rv = 0;\r\n int     pfd[2];\r\n pid_t   pid;\r\n fd_set  set;\r\n struct  timeval timeout;\r\n timeout.tv_sec = mtimeout / 1000;\r\n timeout.tv_usec = mtimeout % 1000 * 1000;\r\n\r\n struct sigaction act, oact;\r\n sigemptyset(&act.sa_mask);\r\n act.sa_handler = sig_child;\r\n act.sa_flags = SA_RESTART;\r\n sigaction(SIGCHLD, &act, &oact);\r\n\r\n if (pipe(pfd) < 0) {\r\n  LOG_ERR(\"Failed to create pipe! error:%d\", errno);\r\n  return QCONF_ERR_OTHER; \r\n }\r\n\r\n if ((pid = fork()) < 0) {\r\n  LOG_ERR(\"Failed to fork process! error:%d\", errno);\r\n  return QCONF_ERR_OTHER; \r\n } \r\n else if (0 == pid) {\r\n  setpgrp();\r\n  close(pfd[0]);\r\n  execl(\"/bin/sh\", \"sh\", \"-c\", script.c_str(), (char *)NULL);\r\n  _exit(127);  // won't be here, if execl was successful\r\n }\r\n\r\n close(pfd[1]);\r\n do {\r\n     FD_ZERO(&set); \r\n     FD_SET(pfd[0], &set);\r\n     rv = select(pfd[0] + 1, &set, NULL, NULL, &timeout);\r\n     if (-1 == rv) {\r\n      if (EINTR == errno) continue;\r\n      else {\r\n       LOG_ERR(\"Failed to select from pipe, error:%d!\", errno);\r\n        break;\r\n      }\r\n     }\r\n     else if(0 == rv) {\r\n      LOG_FATAL_ERR(\"Script execute timeout! script:%s\", script.c_str());\r\n      break;\r\n     }\r\n     else {\r\n      close(pfd[0]); // sub process has exit\r\n      return QCONF_OK;\r\n     }\r\n    } while (true);\r\n\r\n    close(pfd[0]);\r\n    kill(-pid, SIGKILL);\r\n    if (0 == rv) \r\n      return QCONF_ERR_SCRIPT_TIMEOUT;\r\n      \r\n    return QCONF_ERR_OTHER;\r\n}\r\n\r\nstatic void sig_child(int sig) {\r\n pid_t pid;\r\n int status;\r\n while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\r\n  if (WIFEXITED(status)) {\r\n   if (WEXITSTATUS(status)) {\r\n    LOG_ERR(\"Script not exit with success, ret:%d\", WEXITSTATUS(status));\r\n   }\r\n  }\r\n  else {\r\n   LOG_ERR(\"Child process didnot terminate normally, pid:%d\", pid);\r\n  }\r\n }\r\n}\r\n\r\n```\r\ncontinue ……\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}